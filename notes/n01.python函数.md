### `python`函数

#### 1.x 函数基础

#### `python`函数与列表解析表达式

如下 `intersect()`函数的可以使用列表解析表达式来替代：

```python
def intersect(s1, s2):
    res = []
    for x in s1:
        if x in s2:
            res.append(x)
    return res


if "__main__" == __name__:
    s1 = "scam"
    s2 = "pcsm"

    print(intersect(s1, s2))          # ['s', 'c', 'm']
    print([x for x in s1 if x in s2]) # todo: ['s', 'c', 'm']
    pass
```
#### 2.x 变量作用域

#### `python`作用域规则**`LEGB`**

```python

x = 9


def outside():
    # global x  # 加了这一句，表示用的是全局的 x ， 不加，会报错
    print(x)
    x = 3
    var = 5

    def inside():
        # nonlocal var
        print(var)  # inside函数改变了var所以python将var隐藏了起来，这里的print找不到var因而报错。
        var = 3

    inside()


outside()

````
> 参考链接[global与nonlocal关键字总结](https://www.cnblogs.com/themost/p/6359149.html)

#### `Python`工厂函数

> 工厂函数：一个可以记住嵌套作用域的变量值的函数，尽管这个作用域或许已经不存在了。

```python
def marker(N):
    def action(X):
        return X ** N

    return action


print(marker(2)(3))  # 2**3 ? or  3**2 ?

# 输出为9 ，即表明 N=2 , X=3 。 也就是说第一个参数是对应外部函数的参数，第二个对应内部函数的参数
```

> (工厂函数)更严谨的表达方式：

```python
def marker2(N):
    def action2(X, n=N):
        return X ** n

    return action2


print(marker2(2)(3))
```

#### `lambda`表达式

> `lambda`，简短地说，就是一个表达式，将会生成后面调用的一个新的函数，与`def`语句很相似。

```python
def func(z):
    return lambda n, k=z: n ** k


print(func(2)(5))  # 25
```
或者这样：

``` python
def func(z):
    return lambda n: n ** z


print(func(2)(5))  # 25
```

#### 作用域与带有循环变量的默认参数相比较

*一般情况下，不需要给内嵌的`def`/`lambda`代码添加默认参数，以保证逻辑的正确性，但是对于循环变量的情况下，就需要这么做*

```python
def makeActions():
    res = []
    for index in range(5):
        res.append(lambda p: index ** p)
    return res


actions = makeActions()
for act in actions:
    print(act(3)) # 输出的都是 64 . # 64=4**3
```

因为嵌套作用域中的变量，在嵌套函数调用时采取查找。
-- 解决方法就是给内嵌函数传递默认参数，因为默认参数是在内嵌函数创建时评估的（而不是稍后的调用时）。
```python
def makeActions2():
    res = []
    for index in range(5):
        res.append(lambda p, i=index: i ** p)
    return res


actions = makeActions2()
for act in actions:
    print(act(3)) # 输出分别是：0,1,8,27,64
```
*个人以为，应该在任何时候传递默认参数给内嵌的函数，即使内嵌函数并不需要使用外部的参数*。


##### 多级嵌套：

```python
def f1():
    x = 99

    def f2():
        def f3():
            print(x)

        f3()

    f2()


f1() # 输出 99

```
##### `nonlocal`语句

```python
def testter(start):
    state = start

    def nested(label):
        nonlocal state # 如果不加这一句
        print(label, state)
        state += 1   # 这一句就会报错

    return nested


f = testter(2)
f("abc")
f("abc")
f("abc")

```

> 输出如下：

```
abc 2
abc 3
abc 4
```

*`nonlocal` 比`global`的限制更严格*

```python
def tester(start):
    def nested(label):
        nonlocal state
        state = 0
        print(label, state)
    return nested
tester(3)(1)
# 运行报错： SyntaxError: no binding for nonlocal 'state' found
```

```python
def tester(start):
    def nested(label):
        global state
        state = 0
        print(label, state)
    return nested
tester(3)(1)
# 输出：3 1
```

对于上面的这种由于`nonlocal`导致的报错，解决方案就是，要么去掉`nonlocal state`这句，要么就是在外面的`def`语句中加上一个`state=xxx`的初始赋值。

```python
def tester(start):
    state = 9 # 加上这一句就正常了

    def nested(label):
        nonlocal state
        state = 0
        print(label, state)

    return nested


tester(3)(1)
```

使用`global`替代`nonlocal`的问题：
> 在 `python2`中并没有`nonlocal`关键字

使用 `nonlocal`的情形：
```python
# 
def tester(start):
    state = start

    def nested(label):
        nonlocal state
        print(label, state)
        state += 1

    return nested


f = tester(0)
f("php")
f("php")
tester(4)("c++")  # 这个并没有改变 f 中 state 的值，很好！
f("php")
```

> 结果输出：

```
php 0
php 1
c++ 4 
php 2
```

对应的`global`实现：

```python
def tester(start):
    state = start

    def nested(label):
        nonlocal state
        print(label, state)
        state += 1

    return nested


f = tester(0)
f("php")
f("php")
tester(4)("c++")  # 这个改变了 f 中 state 的值
f("php")
```
> 结果输出：

```
php 0
php 1
c++ 4   
php 5   # 看出来已经被改变了
```

*为什么`global`会改变`state`的值，但是`nonlocal`没有？*

因为`nonlocal`会在每次`tester()`调用的时候都会记得`state`对象自己的独特副本。

使用`class`来实现此行为：

```python
class tester:
    def __init__(self, start):
        self.state = start

    def nested(self, label):
        print(label, self.state)
        self.state += 1


t = tester(0)
t.nested("abc")
t.nested("abc")
t.nested("abc")
tester(66).nested("xyz")
t.nested("abc")

```

> 输出如下：

```
abc 0
abc 1
abc 2
xyz 66
abc 3
```

使用 `class`的`__call__`方法实现：

```python
class tester:
    def __init__(self, start):
        self.state = start

    def __call__(self, label):
        print(label, self.state)
        self.state += 1

t = tester(0)
t("abc")
t("abc")
tester(99)("php")
t("abc")
```
> 输出如下：

```
abc 0
abc 1
php 99
abc 2
```

使用 函数属性的方式实现：

```python
def tester(start):
    tester.state = start

    def nested(label):
        print(label, tester.state)
        tester.state += 1

    return nested


f = tester(0)
f('abc')
f('abc')
tester(33)('php')
f('abc')

```
> 输出如下：

``` 
abc 0
abc 1
php 33
abc 34

```

#### 3.x 函数参数

> 参数传递：对象发送给函数的方式....

```python```的函数参数是通过赋值来传递的。和`C`的参数传递机制相似：

* **不可变参数“通过值”来传递** 
* **可变参数“通过指针”来传递**


**特定的参数模型**

* `def`中的`*args`与`**kwargs`[封包]

```python
def f(*args):
    print(args)


f()
f(1)
f(1, 2)
f(1, 2, 3)


def k(**kwargs):
    print(kwargs)


k()
k(a=1)
k(a=1, b=2)
k(a=1, b=2, c=3)


def m(*args, **kwargs):

    print(args, kwargs, sep="\t\t")


m()
m(1)
m(1, 2)
m(1, 2, 3)
m(1, 2, 3, a=1, b=2, c=3)

```

* 调用函数时的`*args`与`**kwargs`[解包]

```python
def f(a, b, c, d):
    print(a, b, c, d)


args = (1, 2, 3, 4)
f(*args)


def f(name, age, value):
    print(name, age, value)


kwargs = {"name": 'bob', "age": 16, "value": 1024}

f(**kwargs)

```

*kwonly*强制关键字参数

```python
def f(a, *b, c):
    print(a, b, c)


f(1, 2, c=3)

# 这里的 c 出现在 *args 之后，按照语法规则，必须是关键字参数，所以调用的时候需要 传入 c=3

##############################################################

def k(*, a, b):
    print(a, b)


k(a=1, b=2)  # 通过 * 强制后面的参数全部必须是关键字参数


def k(*, a=3, b):
    print(a, b)


k(b=9)  # 通过默认参数，可以省略部分传参
k(a=4, b=9)  # 不省略的情况下，依然需要关键字参数

```

look:`*args`使用案例：求一组元素的最小值：

```python
def min1(*args):
    first, *others = args  # 解包1
    # print(args)
    # print("first==" + str(first))
    # print("others==" + str(others))
    for item in others:
        if first > item:
            first = item
    return first


m = min1(*[3, 2, 14, 5])  # 解包1
print("min ", m)
```
> *备注：以上函数并没有对传入的参数做非空之类的判断。这是`python`一贯的做法，只要传入的参数不对，就会自动抛异常，而不是给一个特殊的返回值表示参数错误*。


##### `lambda`表达式

`lambda`表达式，就像`def`一样，创建了一个之后能够调用的函数，但是它返回了一个函数，而不是将这个函数值赋给一个变量名。
> 语法: `lambad ar1,arg2,arg3: expression using args`

示例：
```python
bar = lambda x, y: x + y
print(bar(1, 2)) # 3
```

##### 函数式编程工具`filter`,`reduce`

在`python`内置中，`map`函数是用来函数式编程的这类工具中最简单的内置函数代表。**函数式编程的意思就是对序列应用一些函数的工具**。例如:`map`,`filter`。

#### 迭代和解析

```python
print([ord(z) for z in "hello world"])
```

##### 重访迭代器：生成器

如今`python`对延迟提供了更多支持——它提供了工具在需要的时候才产生结果，而不是立即产生结果。有两种语言结果能够延迟结果构建。（生成器函数，生成器表达式）

**`python`迭代协议：有`__next__`方法的对象会前进到下一个结果，而在一系列结果的末尾时，会触发`StopInteration`异常**。在`python`中，任何这类对象，都任务是可迭代的。任何这类对象都可以通过`for`循环或者其他迭代工具遍历。因为所有迭代工具的内部工作原理都是在每次迭代的时候调用`__next__`方法，并捕获`StopInteration`异常来确定何时离开。

生成器函数与`python`中的迭代协议相关。可迭代的对象定义了一个`__next__`方法，它要么返回下一个值，要么触发`StopInteration`异常来终止迭代。一个对象的迭代器用`iter`内置函数接收。