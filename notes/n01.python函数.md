### `python`函数

#### `python`函数与列表解析表达式

如下 `intersect()`函数的可以使用列表解析表达式来替代：

```python
def intersect(s1, s2):
    res = []
    for x in s1:
        if x in s2:
            res.append(x)
    return res


if "__main__" == __name__:
    s1 = "scam"
    s2 = "pcsm"

    print(intersect(s1, s2))          # ['s', 'c', 'm']
    print([x for x in s1 if x in s2]) # todo: ['s', 'c', 'm']
    pass
```

#### `python`作用域规则**`LEGB`**

```python

x = 9


def outside():
    # global x  # 加了这一句，表示用的是全局的 x ， 不加，会报错
    print(x)
    x = 3
    var = 5

    def inside():
        # nonlocal var
        print(var)  # inside函数改变了var所以python将var隐藏了起来，这里的print找不到var因而报错。
        var = 3

    inside()


outside()

````
> 参考链接[global与nonlocal关键字总结](https://www.cnblogs.com/themost/p/6359149.html)

#### `Python`工厂函数

> 工厂函数：一个可以记住嵌套作用域的变量值的函数，尽管这个作用域或许已经不存在了。

```python
def marker(N):
    def action(X):
        return X ** N

    return action


print(marker(2)(3))  # 2**3 ? or  3**2 ?

# 输出为9 ，即表明 N=2 , X=3 。 也就是说第一个参数是对应外部函数的参数，第二个对应内部函数的参数
```

> (工厂函数)更严谨的表达方式：

```python
def marker2(N):
    def action2(X, n=N):
        return X ** n

    return action2


print(marker2(2)(3))
```

#### `lambda`表达式

> `lambda`，简短地说，就是一个表达式，将会生成后面调用的一个新的函数，与`def`语句很相似。

```python
def func(z):
    return lambda n, k=z: n ** k


print(func(2)(5))  # 25
```
或者这样：

``` python
def func(z):
    return lambda n: n ** z


print(func(2)(5))  # 25
```

#### 作用域与带有循环变量的默认参数相比较

*一般情况下，不需要给内嵌的`def`/`lambda`代码添加默认参数，以保证逻辑的正确性，但是对于循环变量的情况下，就需要这么做*

```python
def makeActions():
    res = []
    for index in range(5):
        res.append(lambda p: index ** p)
    return res


actions = makeActions()
for act in actions:
    print(act(3)) # 输出的都是 64 . # 64=4**3
```

因为嵌套作用域中的变量，在嵌套函数调用时采取查找。
-- 解决方法就是给内嵌函数传递默认参数，因为默认参数是在内嵌函数创建时评估的（而不是稍后的调用时）。
```python
def makeActions2():
    res = []
    for index in range(5):
        res.append(lambda p, i=index: i ** p)
    return res


actions = makeActions2()
for act in actions:
    print(act(3)) # 输出分别是：0,1,8,27,64
```
*个人以为，应该在任何时候传递默认参数给内嵌的函数，即使内嵌函数并不需要使用外部的参数*。


##### 多级嵌套：

```python
def f1():
    x = 99

    def f2():
        def f3():
            print(x)

        f3()

    f2()


f1() # 输出 99

```
##### `nonlocal`语句

```python
def testter(start):
    state = start

    def nested(label):
        nonlocal state # 如果不加这一句
        print(label, state)
        state += 1   # 这一句就会报错

    return nested


f = testter(2)
f("abc")
f("abc")
f("abc")

```

> 输出如下：

```
abc 2
abc 3
abc 4
```

*`nonlocal` 比`global`的限制更严格*

```python
def tester(start):
    def nested(label):
        nonlocal state
        state = 0
        print(label, state)
    return nested
tester(3)(1)
# 运行报错： SyntaxError: no binding for nonlocal 'state' found
```

```python
def tester(start):
    def nested(label):
        global state
        state = 0
        print(label, state)
    return nested
tester(3)(1)
# 输出：3 1
```

对于上面的这种由于`nonlocal`导致的报错，解决方案就是，要么去掉`nonlocal state`这句，要么就是在外面的`def`语句中加上一个`state=xxx`的初始赋值。

```python
def tester(start):
    state = 9 # 加上这一句就正常了

    def nested(label):
        nonlocal state
        state = 0
        print(label, state)

    return nested


tester(3)(1)
```

使用`global`替代`nonlocal`的问题：
> 在 `python2`中并没有`nonlocal`关键字

使用 `nonlocal`的情形：
```python
# 
def tester(start):
    state = start

    def nested(label):
        nonlocal state
        print(label, state)
        state += 1

    return nested


f = tester(0)
f("php")
f("php")
tester(4)("c++")  # 这个并没有改变 f 中 state 的值，很好！
f("php")
```

> 结果输出：

```
php 0
php 1
c++ 4 
php 2
```

对应的`global`实现：

```python
def tester(start):
    state = start

    def nested(label):
        nonlocal state
        print(label, state)
        state += 1

    return nested


f = tester(0)
f("php")
f("php")
tester(4)("c++")  # 这个改变了 f 中 state 的值
f("php")
```
> 结果输出：

```
php 0
php 1
c++ 4   
php 5   # 看出来已经被改变了
```

*为什么`global`会改变`state`的值，但是`nonlocal`没有*？

因为`nonlocal`会在每次`tester()`调用的时候都会记得`state`对象自己的独特副本。
